<#@ template debug="true" hostSpecific="true" language="C#" #> 
<#@ include file="$(SolutionDir)T4\MultipleOutputHelper.ttinclude" #>
<#@ assembly name="System.Xml, Version=4.0.0.0" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Serialization" #>
//generated at : <#= DateTime.Now.ToString(CultureInfo.InvariantCulture) #>
<#
    string templateDir = Path.GetDirectoryName(Host.TemplateFile);
    string xmlTemplate = Path.Combine(templateDir, "InvoiceExpress.xml");
    if (!File.Exists(xmlTemplate))
        return string.Empty;

    var manager = Manager.Create(Host, GenerationEnvironment);

    var xmlConfig = DeserializeXml<Class>(File.ReadAllText(xmlTemplate, Encoding.Default));
    GenerateDtos(manager, xmlConfig);
    GenerateApiCalls(manager, xmlConfig);

    manager.Process(true);
#>
<#+
    private const string BaseNamespace = "InvoicExpress.Net";

    private void GenerateApiCalls(Manager m, Class mc)
    {
        foreach (var api in mc.NestedClass)
        {
            m.StartNewFile(string.Format("{0}.g.cs", api.Name));
            PrintFileHeader();
#>
using System;
using System.Net;
namespace <#=BaseNamespace #>
{
	public static partial class InvoiceExpress
    {
		public static class <#= api.Name #>
		{
	<#+
	    foreach (var mtd in api.Method)
	    {
	        //string inputNameSpace = string.Empty; //String.Format("{0}", mtd.Name);
	        //string returnNameSpace = string.Empty; //String.Format("{0}", mtd.Name);

	        var u = BuildParameters(mtd);
	        string returnClassName = u.ReturnClassName; #>

			/// <summary>
			/// InvoiceExpress <a href="<#= mtd.ApiUrl ?? "" #>"><#=api.Name #> <#=mtd.Name #></a> Method
			/// </summary>
			public static string <#=mtd.Name #>(<#=u.MethodSignatureStr #>)
			{
				string url = <#= u.UrlStringFormat #>;
				var result = url.Http<#= GetHttpMethod(mtd.HttpMethod) #>(<#= u.HasInput ? "inputData" : "" #>);
				if ((int) result.StatusCode != <#=mtd.SucessCode #>)
					throw new System.Exception(string.Format("Invalid HttpStatusCode. Expected {0}", (HttpStatusCode)<#=mtd.SucessCode #>)
						, new Exception(result.Text));
				return result.Text;
			}

			/// <summary>
			/// InvoiceExpress <a href="<#= mtd.ApiUrl ?? "" #>"><#=api.Name #> <#=mtd.Name #></a> Method
			/// </summary>
			public static <#=returnClassName #> <#=mtd.Name #>Typed(<#=u.MethodCallStr #>)
			{
			<#+
	        string deserializePart = u.HasReturn ? string.Format(".DeserializeXml<{0}>()", returnClassName) : string.Empty;
	        string returnPart = u.HasReturn ? "return " : string.Empty;

	        Write("\t");
	        WriteLine(u.HasInput
	            ? string.Format("{0}{1}({2}{3}inputData.XmlSerializeToString()){4};", returnPart, mtd.Name,
	                u.MethodCallParameters, string.IsNullOrEmpty(u.MethodCallParameters) ? "" : ", ", deserializePart)
	            : string.Format("{0}{1}({2}){3};", returnPart, mtd.Name, u.MethodCallParameters, deserializePart));
	        #>
			}
		<#+
	    }
		#>

		}
	}
}<#+
            m.EndBlock();
        }
    }

	 private void GenerateDtos(Manager m, Class c)
	 {
	     foreach (ClassType data in c.Types)
	     {
	         m.StartNewFile(string.Format("{0}.g.cs", data.Name));
#>
using System.Xml.Serialization;
namespace <#= BaseNamespace #>
{
	[XmlRoot("<#= data.XmlName #>")]
	[XmlType(AnonymousType=true)]
	public partial class <#= data.Name #>
	{<#+
	foreach (var p in data.Property)
	{
	    #>
		
		[XmlElement("<#=p.XmlName #>")]
		public <#=p.Type #> <#=p.Name #> { get; set; }
<#+
	}
#>
	}
}
<#+
	         m.EndBlock();
	     }
	 }

    private class UrlParmsHelper
    {
        public string UrlStringFormat { get; set; }
        public bool HasInput { get; set; }
        public bool HasReturn { get; set; }
        public string InputClassName { get; set; }
        public string ReturnClassName { get; set; }
        public string MethodSignatureStr { get; set; }
        public string MethodCallStr { get; set; }
        public string MethodCallParameters { get; set; }
    }

    private string GetHttpMethod(string httpMethod)
    {
        switch (httpMethod.ToLower())
        {
            case "get":
                return "Get";
            case "post":
                return "Post";
            case "create":
                return "Create";
            case "put":
                return "Put";
            case "delete":
                return "Delete";
            default:
                throw new ArgumentOutOfRangeException("httpMethod");
        }
    }

    private UrlParmsHelper BuildParameters(ClassNestedClassMethod m)
    {
        string maskedUrl = m.Url;
        var up = new UrlParmsHelper();

        up.HasInput = !string.IsNullOrEmpty(m.InputClass);
        up.InputClassName = m.InputClass;

        up.HasReturn = !string.IsNullOrEmpty(m.ReturnClass);
        up.ReturnClassName = up.HasReturn ? m.ReturnClass : "void";

        var sbUrlStringFormat = new StringBuilder();
        var sbParameterList = new StringBuilder();
        var sbArgumentList = new StringBuilder();

        if (m.UrlParms != null)
        {
            foreach (var p in m.UrlParms.OrderBy(p => p.Index))
            {
                maskedUrl = maskedUrl.Replace(string.Format("{{{0}}}", p.Name), string.Format("{{{0}}}", p.Index));
                sbUrlStringFormat.Append(string.Format(", {0}", p.Name));
                sbParameterList.Append(sbParameterList.Length > 0
                    ? string.Format(", {0} {1}", p.Type, p.Name)
                    : string.Format("{0} {1}", p.Type, p.Name));

                sbArgumentList.Append(sbArgumentList.Length > 0
                    ? string.Format(", {0}", p.Name)
                    : string.Format("{0}", p.Name));
            }
        }

        string m1SignatureStr = sbParameterList.ToString();
        string m2SignatureStr = m1SignatureStr;
        if (m.InputClass != null)
        {
            m1SignatureStr =
                string.Format("{0}{1}", m1SignatureStr,
                    m1SignatureStr.Length > 0 ? ", string inputData" : "string inputData");
            m2SignatureStr =
                string.Format("{0}{1}", m2SignatureStr,
                    m2SignatureStr.Length > 0
                        ? string.Format(", {0} inputData", up.InputClassName)
                        : string.Format("{0} inputData", up.InputClassName));
        }

        up.UrlStringFormat = string.Format("string.Format(\"{0}\"{1})", maskedUrl, sbUrlStringFormat);
        up.MethodSignatureStr = m1SignatureStr;
        up.MethodCallStr = m2SignatureStr;
        up.MethodCallParameters = sbArgumentList.ToString();
        return up;
    }

    private static T DeserializeXml<T>(string objectData)
    {
        return (T) DeserializeXml(objectData, typeof(T));
    }

    private static object DeserializeXml(string objectData, Type type)
    {
        var serializer = new XmlSerializer(type);
        object result;

        using (var reader = new StringReader(objectData))
            result = serializer.Deserialize(reader);

        return result;
    }

    /*
    private static string XmlToXsd(string xml)
    {
        if (string.IsNullOrEmpty(xml))
            return null;

        using (var rd = new StringReader(xml))
        using (XmlReader xmlReader = XmlReader.Create(rd))
        {
            var schemaInfer = new XmlSchemaInference();
            XmlSchemaSet schemaSet = schemaInfer.InferSchema(xmlReader);

            var sb = new StringBuilder();
            var xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.Indent = true;

            foreach (XmlSchema schema in schemaSet.Schemas())
            {
                using (var stringWriter = new StringWriter())
                using (XmlWriter writer = XmlWriter.Create(stringWriter, xmlWriterSettings))
                {
                    schema.Write(writer);
                    sb.Append(stringWriter);
                }
            }
            return sb.ToString();
        }
    }

    private string XsdToClass(string xsdStr, string nameSpace = "")
    {
        XmlSchema xsd = XmlSchema.Read(new StringReader(xsdStr), null);

        var xsds = new XmlSchemas();
        xsds.Add(xsd);
        xsds.Compile(null, true);
        var schemaImporter = new XmlSchemaImporter(xsds);

        // create the codedom
        var ns = new System.CodeDom.CodeNamespace(nameSpace);
        var codeExporter = new XmlCodeExporter(ns);

        var maps = new List<XmlTypeMapping>();
        foreach (XmlSchemaType schemaType in xsd.SchemaTypes.Values)
            maps.Add(schemaImporter.ImportSchemaType(schemaType.QualifiedName));

        foreach (XmlSchemaElement schemaElement in xsd.Elements.Values)
            maps.Add(schemaImporter.ImportTypeMapping(schemaElement.QualifiedName));

        foreach (XmlTypeMapping map in maps)
            codeExporter.ExportTypeMapping(map);

        RemoveAttributes(ns);
        CodeGenerator.ValidateIdentifiers(ns);

        // output the C# code
        using (var csharp = new CSharpCodeProvider())
        using (var wr = new StringWriter())
        {
            var opts = new CodeGeneratorOptions();
            opts.BlankLinesBetweenMembers = false;
            csharp.GenerateCodeFromNamespace(ns, wr, opts);
            return wr.GetStringBuilder().ToString();
        }
    }

    private void RemoveAttributes(System.CodeDom.CodeNamespace codeNamespace)
    {
        foreach (CodeTypeDeclaration codeType in codeNamespace.Types)
        {
            CodeAttributeDeclaration xmlTypeAttribute = null;
            foreach (CodeAttributeDeclaration codeAttribute in codeType.CustomAttributes)
            {
                if (codeAttribute.Name == "System.Xml.Serialization.XmlTypeAttribute")
                    xmlTypeAttribute = codeAttribute;
            }
            codeType.CustomAttributes.Clear();
            if (xmlTypeAttribute != null)
                codeType.CustomAttributes.Add(xmlTypeAttribute);
        }
    }
	*/

    private void PrintFileHeader()
    {
#>
// Connector API InvoicExpress.Net developed by EventKey,Lda http://www.eventkey.pt
<#+
    }
#>
<#+
    /* classes geradas diretamente do ficheiro InioiceExpress.xml*/


    [XmlType(AnonymousType = true)]
    public class Class
    {
        [XmlElement("NestedClass")]
        public ClassNestedClass[] NestedClass { get; set; }

        [XmlArrayItem("Type", IsNullable = false)]
        public ClassType[] Types { get; set; }

        [XmlAttribute]
        public string Type { get; set; }

        [XmlAttribute]
        public string Name { get; set; }

        [XmlAttribute]
        public string NameSpace { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class ClassNestedClass
    {
        [XmlElement("Method")]
        public ClassNestedClassMethod[] Method { get; set; }

        [XmlAttribute]
        public string Name { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class ClassNestedClassMethod
    {
        [XmlArrayItem("Param", IsNullable = false)]
        public ClassNestedClassMethodParam[] UrlParms { get; set; }

        [XmlText]
        public string[] Text { get; set; }

        [XmlAttribute]
        public string Name { get; set; }

        [XmlAttribute]
        public string HttpMethod { get; set; }

        [XmlAttribute]
        public string Url { get; set; }

        [XmlAttribute]
        public string ApiUrl { get; set; }

        [XmlAttribute]
        public byte SucessCode { get; set; }

        [XmlAttribute]
        public string InputClass { get; set; }

        [XmlAttribute]
        public string ReturnClass { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class ClassNestedClassMethodParam
    {
        [XmlAttribute]
        public byte Index { get; set; }

        [XmlAttribute]
        public string Name { get; set; }

        [XmlAttribute]
        public string Type { get; set; }

        [XmlAttribute]
        public string DefaultValue { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class ClassType
    {
        [XmlElement("Property")]
        public ClassTypeProperty[] Property { get; set; }

        [XmlAttribute]
        public string XmlName { get; set; }

        [XmlAttribute]
        public string Name { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class ClassTypeProperty
    {
        [XmlAttribute]
        public string XmlName { get; set; }

        [XmlAttribute]
        public string Name { get; set; }

        [XmlAttribute]
        public string Type { get; set; }
    }

#>
